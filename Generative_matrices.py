import numpy as np


def generate_codeword(gen_matrix: np.ndarray, num: int) -> str:
    """
    this function takes the generation matrix of a linear code and, after converting given integer num to binary,
    generates single codeword from this binary
    :param gen_matrix:
    :param num:
    :return:
    """
    num_info_bits, num_extra_bits = gen_matrix.shape
    num_extra_bits -= num_info_bits

    bin_str = bin(num)[2:]  # [2:] cuts the "0b" from the beginning
    bin_str = (num_info_bits - len(bin_str)) * "0" + bin_str

    # result matrix has rows from gen_matrix that correspond with the coded message
    result_matrix = np.zeros(gen_matrix.shape, dtype=int)
    for index, row in enumerate(gen_matrix):
        if bin_str[index] == "1":
            result_matrix[index] = row

    result = ""
    for i in range(len(result_matrix[0])):
        temp_sum = np.sum(result_matrix[:, i])
        if temp_sum % 2 == 0:
            result += "0"
        else:
            result += "1"

    return result


def test_matrix(original_matrix: np.ndarray, num_info_bits: int, num_extra_bits: int, num: int,
                desired_hamming_weight=3, show_codewords=False, show_matrix=False):
    """
    This function takes matrix and using num... params turns it into
    generation matrix. Then, using the generation matrix it calculates minimal Hamming weight of the code
    generated by this matrix - which is also minimal Hamming distance of this code

    :param original_matrix: ndarray that has already positional bits in it (i.e. unit matrix on its left side)
    :param num_info_bits: how many informative bits are in the code the original_matrix is generating
    :param num_extra_bits: how many extra (control) bits are in the code the original_matrix is generating
    :param num: number (integer) that is decimal representation of all parity bits in the Generative matrix G.
        If binary representation of this number is shorter than needed, all not-filled positions will be still 0
    :param desired_hamming_weight: self explanatory
    :param show_codewords: if this is set to True then all possible codewords for this matrix will be printed to console
    :param show_matrix: if this is set to True then tested matrix will be printed to console, provided it does not have
        any 0 column in it. Do not use this option when tesing multiple matrices
    :return: does NOT return anything
    """


    # this part tries to construct the Generator matrix G and rejects it if there is any 0 column
    # it assumes that original_matrix will always have only non-zero columns
    matrix: np.ndarray = original_matrix.copy()
    sequence = []
    bin_str = bin(num)[2:]  # [2:] cuts the "0b" from the beginning
    num_places = num_info_bits * num_extra_bits  # how much places in the matrix there is to fill
    bin_str = (num_places - len(bin_str)) * "0" + bin_str
    for bit in bin_str:
        if bit == "1":
            sequence.append(1)
        else:
            sequence.append(0)
    added_part = np.array(sequence)  # part of the Generator array responsible for parity bits
    added_part = np.reshape(added_part, (num_info_bits, num_extra_bits))

    # iterates through added_part's columns and checks if any is only zeroes
    for i in range(len(added_part[0])):
        if np.count_nonzero(added_part[:, i]) == 0:  # if in some COLUMN there are only 0 the matrix is useless
            if show_matrix is True:
                print(f"There is some 0 column! - matrix with num: {num} is useless ")
            return

    matrix[:, num_info_bits:] = added_part
    if show_matrix is True:
        print(matrix)
    # if this function came to this point, then there is already constructed the G matrix
    if show_codewords is True:
        print("Rozpoczyna generowanie slow kodowych...\n")
    min_hamming_weight = num_info_bits + num_extra_bits + 1  # it always begins bigger that it has any right to be
    for i in range(2 ** num_info_bits):
        temp_codeword = generate_codeword(matrix, i)
        if show_codewords is True:
            print(temp_codeword)
        if min_hamming_weight > temp_codeword.count("1") > 0:
            min_hamming_weight = temp_codeword.count("1")

    if show_matrix is True and min_hamming_weight < desired_hamming_weight:
        print(f"Minimal Hamming weight is {min_hamming_weight}")
    if min_hamming_weight >= desired_hamming_weight:
        print(f"For number {num} there was achieved desired hamming weight: {min_hamming_weight}")


def main():
    num_info_bits: int = 4
    num_extra_bits: int = 3
    desired_hamming_weight: int = 3
    print(f"By default parameters are set to:\n-----\nnumber of info bits:{num_info_bits}\nnumber of parity bits:{num_extra_bits}"
          f"\ndesired hamming weight: at least {desired_hamming_weight}\n-----")

    should_loop = True

    while should_loop is True:

        print("\n-----------------------------------------------\nWhat to do? ")
        print("PA - change PArameters")
        print("SA - Search through All matrices with parameters as above")
        print("SS - Show Specific matrix on console. Use this option if appropriate matrix number has "
              "already been found with SA")
        print("GC - Generate all possible Codewords for a specific matrix. -   //   -")
        print("E - End")
        answer = input()
        matrix = np.zeros((num_info_bits, num_info_bits + num_extra_bits), dtype=int)
        for i in range(num_info_bits):
            matrix[i, i] = 1
        match answer.lower():
            case "pa":
                num_info_bits = int(input("How many info bits?"))
                num_extra_bits = int(input("How many parity bits?"))
                desired_hamming_weight = int(input("Minimal Hamming weight?"))
            case "sa":
                for i in range(2 ** (num_extra_bits * num_info_bits)):
                    test_matrix(matrix, num_info_bits, num_extra_bits, i, desired_hamming_weight=desired_hamming_weight)
            case "ss":
                matrix_number = int(input("Give number of a matrix to be shown"))
                test_matrix(matrix, num_info_bits, num_extra_bits, matrix_number, show_matrix=True,
                            desired_hamming_weight=desired_hamming_weight)
            case "gc":
                matrix_number = int(input("Give number of a matrix to generate all codewords"))
                test_matrix(matrix, num_info_bits, num_extra_bits, matrix_number, show_matrix=True,
                            desired_hamming_weight=desired_hamming_weight, show_codewords=True)
            case "e":
                print("Peacefully ending program")
                should_loop = False
            case _:
                print("Option not recognized, ending program")
                should_loop = False


if __name__ == '__main__':
    main()
